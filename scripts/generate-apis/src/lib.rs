use convert_case::{Case, Casing as _};

pub mod db;
pub mod gen;

/// Stock warning to add to all generated files.
static GENERATED_CONTENT_WARNING: &str = r#"// #############################################################################
//  WARNING:
//  This file is generated by scripts/generate-apis. Do not modify it manually.
// #############################################################################"#;

/// A firmware version
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Version {
	pub major: u8,
	pub minor: u8,
}
impl Version {
	pub fn source_display(self) -> VersionSourceDisplay {
		VersionSourceDisplay(self)
	}
}

impl std::fmt::Display for Version {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}.{:0>2}", self.major, self.minor)
	}
}

impl PartialEq<(u8, u8)> for Version {
	fn eq(&self, other: &(u8, u8)) -> bool {
		self.major == other.0 && self.minor == other.1
	}
}

impl PartialOrd<(u8, u8)> for Version {
	fn partial_cmp(&self, other: &(u8, u8)) -> Option<std::cmp::Ordering> {
		PartialOrd::partial_cmp(&(self.major, self.minor), other)
	}
}

/// A type for properly formatting a [`Version`] as an identifier in Rust source code.
#[derive(Debug, Copy, Clone)]
pub struct VersionSourceDisplay(Version);
impl std::fmt::Display for VersionSourceDisplay {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(f, "{}_{:0>2}", self.0.major, self.0.minor)
	}
}

/// The scope of the setting
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Default)]
pub enum Scope {
	Axis,
	#[default]
	Device,
}
impl Scope {
	fn trait_name(self) -> &'static str {
		match self {
			Scope::Axis => "AxisScope",
			Scope::Device => "DeviceScope",
		}
	}
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct AsciiVariant {
	/// The ParamType ID
	param_type: u32,
	/// The EnumType ID
	enum_type: Option<u32>,
}

/// Format the setting name base on a specific case.
///
/// This only supports `UpperSnake`, `Snake`, and `UpperCamel`. Using any
/// other type results in a panic.
fn format_setting_name(name: &str, case: Case) -> String {
	let mut formatted_name = String::new();
	let mut capitalize = case != Case::Snake;
	for c in name.chars() {
		if c == '.' {
			capitalize = case == Case::UpperSnake || case == Case::UpperCamel;
			if case == Case::Snake || case == Case::UpperSnake {
				formatted_name.push('_');
			}
		} else if c == '_' {
			// skip it.
		} else if capitalize {
			formatted_name.push(c.to_ascii_uppercase());
			capitalize = match case {
				Case::Snake | Case::UpperCamel => false,
				Case::UpperSnake => true,
				_ => unimplemented!(),
			};
		} else {
			formatted_name.push(c.to_ascii_lowercase());
		}
	}
	formatted_name
}
/// Get the name of the setting for use in Rust source code as the name of a type.
pub fn setting_rust_type_name(name: &str) -> String {
	format_setting_name(name, Case::UpperCamel)
}
/// The link to the protocol manual for this setting.
pub fn protocol_manual_link(name: &str, version: Version) -> String {
	match version.major {
		7 => format!(
			"https://www.zaber.com/protocol-manual#topic_setting_{}",
			format_setting_name(name, Case::Snake)
		),
		6 => format!(
			"https://www.zaber.com/w/Manuals/ASCII_Protocol_Manual#{}",
			name
		),
		_ => panic!("unsupported firmware version {version}"),
	}
}

/// An Enum defined in the database.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
	/// The name of the enum.
	pub name: String,
	/// The description in the database.
	pub description: Option<String>,
	/// The variants in the enum.
	pub variants: Vec<EnumVariant>,
}

impl Enum {
	/// Get the name of the enum for use in Rust source code as the name of a type.
	pub fn rust_type_name(&self) -> String {
		self.name.to_case(Case::UpperCamel)
	}
}

/// A variant within an Enum
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
	/// The name of the variant
	pub name: String,
	/// The description of the variant, if any.
	pub description: Option<String>,
}

/// A parameter type from the database.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamType {
	/// The name of the parameter.
	pub name: String,
}

impl ParamType {
	/// Whether this parameter type is an Enum.
	pub fn is_enum(&self) -> bool {
		self.name.as_str() == "Enum"
	}
	/// Get the name of Rust type associated with the parameter type.
	///
	/// If the parameter type is `Enum` then `None` is returned.
	pub fn rust_type_name(&self) -> Option<&'static str> {
		match self.name.as_str() {
			"Enum" => None,
			"Uint8" => Some("u8"),
			"Uint16" => Some("u16"),
			"Uint32" | "Uint" => Some("u32"),
			"Uint64" => Some("u64"),
			"Int8" => Some("i8"),
			"Int16" => Some("i16"),
			"Int32" | "Int" => Some("i32"),
			"Int64" => Some("i64"),
			"Bool" => Some("bool"),
			"Uint16DP1" | "Uint16DP2" | "Uint16DP3" | "Uint32DP1" | "Int32DP2" | "Uint32DP3"
			| "UintDP1" | "Int16DP1" | "Int32DP3" | "Int32DP6" | "IntDP1" | "Tenths"
			| "Utenths" | "UTenths" | "Uhalves32" => Some("f32"),
			"Uint64DP1" | "Uint64DP9" | "Int64DP9" | "Int64DP1" => Some("f64"),
			"Token" => Some("::std::string::String"),
			"MACAddress" => Some("crate::ascii::setting::data_types::MacAddress"),
			"IPv4Address" | "IPv4Mask" => Some("::std::net::Ipv4Addr"),
			name => panic!("unsupported param type '{name}'"),
		}
	}
}
